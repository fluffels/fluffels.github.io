<html lang="en">
    <head>
        <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
        <meta content="utf-8" http-equiv="encoding">
        <title>
            Quake Sky
        </title>
        <style type="text/css">
            body {
                font-family: Helvetica, Arial, sans-serif;
                background-color: #eee8d5;
                color: #073642;
                max-width: 800px;
                margin-left: auto;
                margin-right: auto;
            }

            a {
                color: #268bd2;
                text-decoration: none;
            }

            a:visited {
                color: #268bd2;
            }

            a:hover {
                color: #268bd2;
                text-decoration: underline;
            }

            p {
                text-align: justify;
            }

            img {
                width: 100%;
            }
        </style>
    </head>
    <body>
        <h1>Quake Sky</h1>
        <p>
            Recently I've been working on a <a href="https://github.com/fluffels/kwark">Quake BSP renderer</a>.
            I've been trying to reverse engineer as much as I can from descriptions of the Quake engine found on the internet.
            One thing that's not described very well is how Quake handles the sky.
            This post will describe how this is implemented in other engines and how I ended up implementing it.
        </p>
        <p>
            First a video of how it should look.
            This is taken from the intro level in <a href="https://github.com/Novum/vkQuake">vkQuake</a>.
        </p>
        <video controls width="800">
            <source src="https://media.githubusercontent.com/media/fluffels/fluffels.github.io/master/vkquake_sky.webm" type="video/webm">
            Sorry, your browser doesn't support embedded videos.
        </video>
        <p>
            Next some details I could gather about how Quake renders skies:
            <ul>
                <li><a href="http://www.celephais.net/stuff/texturefaq.htm">Quake sky textures are 128x256, where the left half is a "front" texture and the right half is a "back" texture</a>
                <li>Scrolling these textures at different rates gives a <a href="https://en.wikipedia.org/wiki/Parallax">parallax</a> effect that gives the sky some depth.
                <li><a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm">The Sky effect is achieved by pretending the viewer is farther away than they actually are.</a>
            </ul>
        </p>
        <p>
            Not really enough information to recreate the effect so I decided to take a look at how vkQuake does it.
            RenderDoc shows roughly how the level is rendered.
        </p>
        <video controls width="800">
            <source src="https://media.githubusercontent.com/media/fluffels/fluffels.github.io/master/vkquake_sky_rd.webm" type="video/webm">
            Sorry, your browser doesn't support embedded videos.
        </video>
        <p>
            vkQuake renders a simple flat-colored version of the sky and then fills it in.
            Setting <code>r_fastsky</code> will skip the second step, presumably offering some performance improvements.
            Since modern hardware is so fast, this can be left out.
        </p>
        <p>
            The detailed pass is somewhat odd in that it is rendering several small squares instead of the same regions filled in by the fastsky pass.
            These squares are not present in the actual BSP file for the level.
            The BSP geometry looks something like this:
        </p>
        <img src="https://media.githubusercontent.com/media/fluffels/fluffels.github.io/master/sky_geom_rd.jpeg" />
        <p>
            vkQuake generates these tiles at runtime from the extents of the whole skybox.
            I.e. the minimum and maximum of the skybox along each of the X, Y and Z axes.
            Each skybox face is aligned along one of these axes.
            So when it is time to render that face it is extended along the extents for that axis and split up into tiles before being rendered.
            See <a href="https://github.com/Novum/vkQuake/blob/master/Quake/gl_sky.c">gl_sky.c</a> for more detail.
        </p>
        <p>
            This is somewhat complicated and results in some overdraw.
            Maybe there is a simpler approach?
        </p>
        <p>
            It shouldn't be necessary to render these squares since the entire area to be filled is covered by the sky meshes that are already present in the BSP.
            Simply rendering them with no animation and with the normal Quake texture coordinates results in this:
        </p>
        <img src="https://raw.githubusercontent.com/fluffels/fluffels.github.io/master/sky_texture.jpg" />
        <p>
            This screenshot shows what the actual level geometry looks like, but the perspective incorrect.
            The sky is supposed to be very far away from the observer.
            Here, since it is part of the level geometry it is actually really close.
            Luckily there is a way to fake this distance without messing with the actual vertices.
        </p>
        <p>
            If the observer is very far away from the sky then the position of the observer should not have any effect on how it is displayed.
            If you're out walking you don't see clouds getting any closer.
            It's like they're fixed in place.
            However, turning your head will show you different parts of the sky.
            So the part of the texture we're rendering depends only on the vector between the point being rendered and the observer.
        </p>
        <p>
            I passed the location of the camera as a uniform and subtracted it from the position to get this vector:
        </p>
        <pre>
            vec3 dir = inPosition - uniforms.origin;
        </pre>
        <p>
            Next, the vector should be normalized.
            This is because the sky is supposed to be very far away, so how close you actually are to the point should have no effect on the final calculation.
        </p>
        <pre>
            dir = normalize(dir);
        </pre>
        <p>
            Finally project the vector onto the texture space.
            (Actually the front and back texture need separate tex coords, but for now set them to the same vector.)
        </p>
        <pre>
            vec2 texCoord = vec2(dir.x, dir.z);
        </pre>
        <img src="https://media.githubusercontent.com/media/fluffels/fluffels.github.io/master/sky_texture_2.png" />
        <p>
            This looks vaguely correct, except the scale is slightly off and it's not animated.
            There isn't really a way to reverse engineer the scale, but looking at vkQuake source gives the following for computing the texture coordinates:
        </p>
        <pre>
            void Sky_GetTexCoord (vec3_t v, float speed, float *s, float *t)
            {
                vec3_t	dir;
                float	length, scroll;

                VectorSubtract (v, r_origin, dir);
                dir[2] *= 3;	// flatten the sphere

                length = dir[0]*dir[0] + dir[1]*dir[1] + dir[2]*dir[2];
                length = sqrt (length);
                length = 6*63/length;

                scroll = cl.time*speed;
                scroll -= (int)scroll & ~127;

                *s = (scroll + dir[0] * length) * (1.0/128);
                *t = (scroll + dir[1] * length) * (1.0/128);
            }
        </pre>
        <p>
            The <code>length</code> variable here is using the dot product to compute the square of the magnitude of the vector.
            The call to <code>sqrt</code> converts this to the magnitude.
            Next it is multiplied by 6*63.
            Finally <code>length</code> is multiplied by the X and Z axes of the <code>dir</code> vector.
            This is doing the same as normalizing the vector and then scaling it by a constant.
            Multiplying the Y axis is skipped since it's not used in the final calculation.
        </p>
        <p>
            The multiplication by 1/128 is scaling by the height/width of the texture.
            This is necessary to go from world space coordinates to texture coordinates.
        </p>
        <p>
            The <code>scroll</code> variable has to do with the animation effect so it can be ignored for now.
        </p>
        <p>
            So all that should be necessary to fix the scaling would be a multiplication by 6*63 and a division by 128.
        </p>
        <pre>
            vec3 dir = normalize(dir) * 6*63 / 128.f;
        </pre>
        <img src="https://media.githubusercontent.com/media/fluffels/fluffels.github.io/master/sky_texture_3.png" />
    </body>
</html>
